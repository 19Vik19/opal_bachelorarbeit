/* BSD 2-Clause License - see OPAL/LICENSE for details. */
package org.opalj.ll.cg

import com.fasterxml.jackson.databind.json.JsonMapper
import com.fasterxml.jackson.module.scala.DefaultScalaModule
import org.opalj.ll.LLVMProject
import org.opalj.ll.llvm.value.Function

import scala.collection.mutable.ArrayBuffer
import scala.io.Source

object PhasarCallGraphParser {
    type PhasarCallGraph = Map[Function, Seq[Function]]
    type PhasarCallGraphJson = Map[String, Map[String, Seq[String]]]

    /**
     * Parses a call graph in JSON format that was generated by phasar.
     *
     * @param cgJsonPath  the path to the JSON file.
     * @param llvmProject the corresponding LLVM project.
     * @return the call graph.
     */
    def parse(cgJsonPath: String, llvmProject: LLVMProject): PhasarCallGraph = {
        val jsonFile = Source.fromFile(cgJsonPath)
        val mapper = JsonMapper.builder()
            .addModule(DefaultScalaModule)
            .build()
        val stringCallGraph = mapper.readValue(jsonFile.reader(), classOf[PhasarCallGraphJson])("psr.cg")
        val callGraph = scala.collection.mutable.Map.empty[Function, Seq[Function]]
        for ((caller, callees) <- stringCallGraph) {
            val callerFunc = llvmProject.function(caller)
            if (callerFunc.isDefined) {
                val calleeFuncs = ArrayBuffer[Function]()
                for (callee <- callees) {
                    val calleeFunc = llvmProject.function(callee)
                    if (calleeFunc.isDefined) {
                        calleeFuncs.append(calleeFunc.get)
                    }
                }
                callGraph.addOne(callerFunc.get -> calleeFuncs.toSeq)
            }
        }
        callGraph.toMap
    }
}
